#include <opencv2/core/utility.hpp>
#include "opencv2/video/tracking.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/highgui.hpp"

#include <iostream>
#include <ctype.h>

using namespace cv;
using namespace std;

Mat image;

int previous_selection_height = 0;
bool selectObject = false;
bool new_selection = false;
int trackObject = 0;
Point origin;
Rect selection;
int vmin = 10, vmax = 256, smin = 30;
// focal_length = focal length given by manufacturer in mm. 
// f_x and f_y values (pixels) in CameraMatrix output that was generated by CameraCalibration code are same value so I simplified to just f.
// actual_object_height is the real world height of the object in mm. Hardcoded for testing purposes.
double focal_length = 2.1, f = 396.83218974894680, actual_object_height = 146.3;
// camera resolution is 1920x1080. Aspect ratio is 640x480.
int camera_resolution_x = 1920, camera_resolution_y = 1080, aspect_ratio_x = 640, aspect_ratio_y = 480;
// pixels/mm ratio
double px_per_mm = f / focal_length;
// pixels/mm after being scaled down to the 640x480 aspect ratio
double scaled_px_per_mm = (aspect_ratio_x * px_per_mm) / camera_resolution_x;

Mat cameraMatrix = (Mat_<double>(3, 3) << 3.9683218974894680e+02, 0., 3.1950000000000000e+02, 0.,
	3.9683218974894680e+02, 2.3950000000000000e+02, 0., 0., 1.);
Mat distCoeffs = (Mat_<double>(5, 1) << -4.5596899020020748e-01, 2.5706133556827276e-01, 0., 0.,
	-7.4662921360934026e-02);
Mat R, map1, map2, undistortedframe;

static void onMouse(int event, int x, int y, int, void*)
{
	if (selectObject)
	{
		selection.x = MIN(x, origin.x);
		selection.y = MIN(y, origin.y);
		selection.width = std::abs(x - origin.x);
		selection.height = std::abs(y - origin.y);
		selection &= Rect(0, 0, image.cols, image.rows);
	}

	switch (event)
	{
	case EVENT_LBUTTONDOWN:
		origin = Point(x, y);
		selection = Rect(x, y, 0, 0);
		selectObject = true;
		new_selection = false;
		break;
	case EVENT_LBUTTONUP:
		selectObject = false;
		if (selection.width > 0 && selection.height > 0)
			new_selection = true;
			trackObject = -1;
		break;
	}
}


int main(int argc, const char** argv)
{
	VideoCapture cap;
	Rect trackWindow;
	int hsize = 16;
	float hranges[] = { 0,180 };
	const float* phranges = hranges;
	cap.open(1);

	if (!cap.isOpened())
	{
		cout << "***Could not initialize capturing...***\n";
		return -1;
	}
	namedWindow("CamShift Demo", 0);
	setMouseCallback("CamShift Demo", onMouse, 0);

	int frame_width = cap.get(CV_CAP_PROP_FRAME_WIDTH);
	int frame_height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

	VideoWriter video("output.avi", CV_FOURCC('M', 'J', 'P', 'G'), 6, Size(frame_width, frame_height), true);
	Mat frame;
	bool paused = false;

	for (;;)
	{
		if (!paused)
		{
			cap >> frame;
			if (frame.empty())
				break;
		}

		cv::initUndistortRectifyMap(cameraMatrix, distCoeffs, Matx33d::eye(), cameraMatrix, Size(640, 480), CV_16SC2, map1, map2);
		cv::remap(frame, undistortedframe, map1, map2, CV_INTER_LINEAR);
		undistortedframe.copyTo(image);

		if (!paused)
		{
			if (selectObject && selection.width > 0 && selection.height > 0)
			{
				Mat roi(image, selection);
				bitwise_not(roi, roi);
			}
			rectangle(image, selection, Scalar(0, 255, 0), 2);
			// object height as it appears in the image in pixels
			double object_height_image = selection.height / scaled_px_per_mm;
			//distance from object to camera in mm
			double distance = (actual_object_height * focal_length) / object_height_image;
			if (previous_selection_height != selection.height && new_selection == true)
			{
				cout << "Height of object in image is: " << selection.height << " pixels" << endl;
				cout << "Distance from object to camera is: " << distance << " mm" << endl;
				previous_selection_height = selection.height;
			}
		//string text ;
		/*int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
		double fontScale = 1;
		int thickness = 2;
		cv::Point textOrg(10, 130);
		cv::putText(image, selection.height, textOrg, fontFace, fontScale, Scalar::all(255), thickness, 8);*/
		imshow("CamShift Demo", image);

		char c = (char)waitKey(10);
		if (c == 27)
			break;
		}
	}

	return 0;
}